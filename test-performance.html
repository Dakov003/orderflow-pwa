<!DOCTYPE html>
<html lang="ro">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test Performance - OrderFlow PWA</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        .header {
            background: linear-gradient(135deg, #0ea5e9 0%, #3b82f6 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        .content {
            padding: 30px;
        }
        .test-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        .test-card {
            background: #f8fafc;
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            padding: 20px;
            transition: all 0.3s ease;
        }
        .test-card:hover {
            border-color: #0ea5e9;
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
        }
        .test-button {
            background: linear-gradient(135deg, #0ea5e9 0%, #3b82f6 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            margin: 5px;
            transition: all 0.3s ease;
        }
        .test-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(14, 165, 233, 0.3);
        }
        .test-button:disabled {
            background: #94a3b8;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        .results {
            background: #1e293b;
            color: #e2e8f0;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            max-height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
        }
        .app-frame {
            width: 100%;
            height: 600px;
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            margin-top: 20px;
        }
        .performance-chart {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
        }
        .metric {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #e2e8f0;
        }
        .metric:last-child {
            border-bottom: none;
        }
        .metric-value {
            font-weight: bold;
            color: #0ea5e9;
        }
        .metric-good {
            color: #10b981;
        }
        .metric-warning {
            color: #f59e0b;
        }
        .metric-bad {
            color: #ef4444;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>âš¡ Test Performance - OrderFlow PWA</h1>
            <p>TesteazÄƒ performanÈ›a È™i optimizÄƒrile aplicaÈ›iei</p>
        </div>

        <div class="content">
            <div class="test-grid">
                <div class="test-card">
                    <h3>â±ï¸ Timpuri de ÃncÄƒrcare</h3>
                    <p>TesteazÄƒ timpii de Ã®ncÄƒrcare È™i rÄƒspuns</p>
                    <button class="test-button" onclick="testLoadTimes()">TesteazÄƒ Timpuri</button>
                    <button class="test-button" onclick="testNetworkPerformance()">TesteazÄƒ ReÈ›ea</button>
                    <div class="results" id="loadResults"></div>
                </div>

                <div class="test-card">
                    <h3>ğŸ’¾ Utilizare Memorie</h3>
                    <p>TesteazÄƒ utilizarea memoriei È™i CPU</p>
                    <button class="test-button" onclick="testMemoryUsage()">TesteazÄƒ Memorie</button>
                    <button class="test-button" onclick="testCPUUsage()">TesteazÄƒ CPU</button>
                    <div class="results" id="memoryResults"></div>
                </div>

                <div class="test-card">
                    <h3>ğŸ“¦ Dimensiuni Bundle</h3>
                    <p>TesteazÄƒ dimensiunile fiÈ™ierelor</p>
                    <button class="test-button" onclick="testBundleSizes()">TesteazÄƒ Bundle</button>
                    <button class="test-button" onclick="testAssetOptimization()">TesteazÄƒ Assets</button>
                    <div class="results" id="bundleResults"></div>
                </div>

                <div class="test-card">
                    <h3>ğŸ¯ Core Web Vitals</h3>
                    <p>TesteazÄƒ metricile Core Web Vitals</p>
                    <button class="test-button" onclick="testCoreWebVitals()">TesteazÄƒ CWV</button>
                    <button class="test-button" onclick="testLighthouse()">TesteazÄƒ Lighthouse</button>
                    <div class="results" id="vitalsResults"></div>
                </div>
            </div>

            <div class="test-card">
                <h2>ğŸ“Š Dashboard PerformanÈ›Äƒ</h2>
                <div class="performance-chart" id="performanceChart">
                    <h3>Metrici de PerformanÈ›Äƒ</h3>
                    <div class="metric">
                        <span>Timp Ã®ncÄƒrcare iniÈ›ial:</span>
                        <span class="metric-value" id="loadTime">-</span>
                    </div>
                    <div class="metric">
                        <span>Memorie folositÄƒ:</span>
                        <span class="metric-value" id="memoryUsed">-</span>
                    </div>
                    <div class="metric">
                        <span>Dimensiune bundle:</span>
                        <span class="metric-value" id="bundleSize">-</span>
                    </div>
                    <div class="metric">
                        <span>NumÄƒr de request-uri:</span>
                        <span class="metric-value" id="requestCount">-</span>
                    </div>
                    <div class="metric">
                        <span>FPS mediu:</span>
                        <span class="metric-value" id="fps">-</span>
                    </div>
                </div>
            </div>

            <div class="test-card">
                <h2>ğŸŒ AplicaÈ›ia OrderFlow</h2>
                <p>MonitorizeazÄƒ performanÈ›a Ã®n timp real:</p>
                <iframe src="http://localhost:4173" class="app-frame" id="appFrame"></iframe>
            </div>

            <div class="test-card">
                <h2>ğŸ“Š Raport PerformanÈ›Äƒ</h2>
                <button class="test-button" onclick="generatePerformanceReport()" style="background: linear-gradient(135deg, #10b981 0%, #059669 100%);">
                    GenereazÄƒ Raport
                </button>
                <div class="results" id="performanceReport"></div>
            </div>
        </div>
    </div>

    <script>
        let performanceResults = {
            loadTimes: {},
            memory: {},
            bundle: {},
            vitals: {},
            realTime: {}
        };

        // MonitorizeazÄƒ performanÈ›a Ã®n timp real
        let performanceMonitor = null;
        let fpsCounter = 0;
        let lastTime = performance.now();

        function startPerformanceMonitoring() {
            if (performanceMonitor) return;
            
            performanceMonitor = setInterval(() => {
                updatePerformanceMetrics();
            }, 1000);
        }

        function stopPerformanceMonitoring() {
            if (performanceMonitor) {
                clearInterval(performanceMonitor);
                performanceMonitor = null;
            }
        }

        function updatePerformanceMetrics() {
            // ActualizeazÄƒ FPS
            const currentTime = performance.now();
            const deltaTime = currentTime - lastTime;
            const fps = Math.round(1000 / deltaTime);
            lastTime = currentTime;
            
            document.getElementById('fps').textContent = fps + ' FPS';
            document.getElementById('fps').className = 'metric-value ' + (fps >= 30 ? 'metric-good' : fps >= 15 ? 'metric-warning' : 'metric-bad');
            
            // ActualizeazÄƒ memoria
            if (performance.memory) {
                const usedMemory = Math.round(performance.memory.usedJSHeapSize / 1024 / 1024);
                document.getElementById('memoryUsed').textContent = usedMemory + ' MB';
                document.getElementById('memoryUsed').className = 'metric-value ' + (usedMemory < 50 ? 'metric-good' : usedMemory < 100 ? 'metric-warning' : 'metric-bad');
            }
        }

        function testLoadTimes() {
            const results = document.getElementById('loadResults');
            let result = 'â±ï¸ Testare Timpuri de ÃncÄƒrcare:\n';
            
            try {
                if (window.performance) {
                    const timing = window.performance.timing;
                    const navigation = window.performance.navigation;
                    
                    // CalculeazÄƒ timpii
                    const loadTime = timing.loadEventEnd - timing.navigationStart;
                    const domContentLoaded = timing.domContentLoadedEventEnd - timing.navigationStart;
                    const firstPaint = timing.responseEnd - timing.requestStart;
                    
                    result += `â±ï¸ Timp Ã®ncÄƒrcare total: ${loadTime}ms\n`;
                    result += `â±ï¸ DOM Content Loaded: ${domContentLoaded}ms\n`;
                    result += `â±ï¸ First Paint: ${firstPaint}ms\n`;
                    
                    // EvalueazÄƒ performanÈ›a
                    if (loadTime < 3000) {
                        result += 'âœ… PerformanÈ›Äƒ excelentÄƒ (< 3s)\n';
                    } else if (loadTime < 5000) {
                        result += 'âš ï¸ PerformanÈ›Äƒ bunÄƒ (3-5s)\n';
                    } else {
                        result += 'âŒ PerformanÈ›Äƒ slabÄƒ (> 5s)\n';
                    }
                    
                    performanceResults.loadTimes.total = loadTime;
                    performanceResults.loadTimes.domContentLoaded = domContentLoaded;
                    performanceResults.loadTimes.firstPaint = firstPaint;
                    
                    // ActualizeazÄƒ dashboard-ul
                    document.getElementById('loadTime').textContent = loadTime + 'ms';
                    document.getElementById('loadTime').className = 'metric-value ' + (loadTime < 3000 ? 'metric-good' : loadTime < 5000 ? 'metric-warning' : 'metric-bad');
                    
                } else {
                    result += 'âŒ Performance API nu este suportat\n';
                }
                
            } catch (error) {
                result += `âŒ Eroare la testarea timpilor: ${error.message}\n`;
            }
            
            results.innerHTML = result;
        }

        function testNetworkPerformance() {
            const results = document.getElementById('loadResults');
            let result = results.innerHTML + '\n\nğŸŒ Testare PerformanÈ›Äƒ ReÈ›ea:\n';
            
            try {
                const iframe = document.getElementById('appFrame');
                const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                
                // NumÄƒrÄƒ resursele Ã®ncÄƒrcate
                const scripts = iframeDoc.querySelectorAll('script[src]');
                const stylesheets = iframeDoc.querySelectorAll('link[rel="stylesheet"]');
                const images = iframeDoc.querySelectorAll('img[src]');
                
                result += `ğŸ“¦ Scripturi: ${scripts.length}\n`;
                result += `ğŸ¨ Stylesheets: ${stylesheets.length}\n`;
                result += `ğŸ–¼ï¸ Imagini: ${images.length}\n`;
                
                const totalResources = scripts.length + stylesheets.length + images.length;
                result += `ğŸ“Š Total resurse: ${totalResources}\n`;
                
                // ActualizeazÄƒ dashboard-ul
                document.getElementById('requestCount').textContent = totalResources;
                document.getElementById('requestCount').className = 'metric-value ' + (totalResources < 20 ? 'metric-good' : totalResources < 50 ? 'metric-warning' : 'metric-bad');
                
                performanceResults.loadTimes.resources = totalResources;
                
            } catch (error) {
                result += `âŒ Eroare la testarea reÈ›elei: ${error.message}\n`;
            }
            
            results.innerHTML = result;
        }

        function testMemoryUsage() {
            const results = document.getElementById('memoryResults');
            let result = 'ğŸ’¾ Testare Utilizare Memorie:\n';
            
            try {
                if (performance.memory) {
                    const memory = performance.memory;
                    const used = Math.round(memory.usedJSHeapSize / 1024 / 1024);
                    const total = Math.round(memory.totalJSHeapSize / 1024 / 1024);
                    const limit = Math.round(memory.jsHeapSizeLimit / 1024 / 1024);
                    
                    result += `ğŸ’¾ Memorie folositÄƒ: ${used} MB\n`;
                    result += `ğŸ’¾ Memorie totalÄƒ: ${total} MB\n`;
                    result += `ğŸ’¾ Limita memorie: ${limit} MB\n`;
                    result += `ğŸ“Š Procent folosit: ${Math.round((used / limit) * 100)}%\n`;
                    
                    // EvalueazÄƒ utilizarea memoriei
                    const usagePercent = (used / limit) * 100;
                    if (usagePercent < 50) {
                        result += 'âœ… Utilizare memorie bunÄƒ (< 50%)\n';
                    } else if (usagePercent < 80) {
                        result += 'âš ï¸ Utilizare memorie moderatÄƒ (50-80%)\n';
                    } else {
                        result += 'âŒ Utilizare memorie mare (> 80%)\n';
                    }
                    
                    performanceResults.memory.used = used;
                    performanceResults.memory.total = total;
                    performanceResults.memory.limit = limit;
                    performanceResults.memory.usagePercent = usagePercent;
                    
                } else {
                    result += 'âŒ Memory API nu este suportat\n';
                }
                
            } catch (error) {
                result += `âŒ Eroare la testarea memoriei: ${error.message}\n`;
            }
            
            results.innerHTML = result;
        }

        function testCPUUsage() {
            const results = document.getElementById('memoryResults');
            let result = results.innerHTML + '\n\nğŸ–¥ï¸ Testare Utilizare CPU:\n';
            
            try {
                // TesteazÄƒ performanÈ›a prin mÄƒsurarea timpului de execuÈ›ie
                const startTime = performance.now();
                
                // ExecutÄƒ o operaÈ›iune intensivÄƒ
                let sum = 0;
                for (let i = 0; i < 1000000; i++) {
                    sum += Math.random();
                }
                
                const endTime = performance.now();
                const executionTime = endTime - startTime;
                
                result += `â±ï¸ Timp execuÈ›ie test: ${executionTime.toFixed(2)}ms\n`;
                
                if (executionTime < 10) {
                    result += 'âœ… CPU performant (< 10ms)\n';
                } else if (executionTime < 50) {
                    result += 'âš ï¸ CPU moderat (10-50ms)\n';
                } else {
                    result += 'âŒ CPU lent (> 50ms)\n';
                }
                
                performanceResults.memory.cpuTest = executionTime;
                
            } catch (error) {
                result += `âŒ Eroare la testarea CPU: ${error.message}\n`;
            }
            
            results.innerHTML = result;
        }

        function testBundleSizes() {
            const results = document.getElementById('bundleResults');
            let result = 'ğŸ“¦ Testare Dimensiuni Bundle:\n';
            
            try {
                const iframe = document.getElementById('appFrame');
                const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                
                // AnalizeazÄƒ scripturile
                const scripts = iframeDoc.querySelectorAll('script[src]');
                let totalScriptSize = 0;
                let scriptCount = 0;
                
                scripts.forEach(script => {
                    if (script.src.includes('assets/')) {
                        scriptCount++;
                        // EstimeazÄƒ dimensiunea (nu putem accesa real size din cauza CORS)
                        totalScriptSize += 100; // Estimare conservatoare
                    }
                });
                
                result += `ğŸ“¦ Scripturi bundle: ${scriptCount}\n`;
                result += `ğŸ“Š Dimensiune estimatÄƒ: ${totalScriptSize} KB\n`;
                
                // AnalizeazÄƒ CSS-ul
                const stylesheets = iframeDoc.querySelectorAll('link[rel="stylesheet"]');
                let cssCount = 0;
                
                stylesheets.forEach(link => {
                    if (link.href.includes('assets/')) {
                        cssCount++;
                    }
                });
                
                result += `ğŸ¨ CSS bundle: ${cssCount}\n`;
                
                const totalBundleSize = totalScriptSize + (cssCount * 20); // Estimare CSS
                result += `ğŸ“Š Dimensiune totalÄƒ estimatÄƒ: ${totalBundleSize} KB\n`;
                
                // EvalueazÄƒ dimensiunea bundle-ului
                if (totalBundleSize < 500) {
                    result += 'âœ… Bundle mic (< 500 KB)\n';
                } else if (totalBundleSize < 1000) {
                    result += 'âš ï¸ Bundle moderat (500 KB - 1 MB)\n';
                } else {
                    result += 'âŒ Bundle mare (> 1 MB)\n';
                }
                
                performanceResults.bundle.scripts = scriptCount;
                performanceResults.bundle.css = cssCount;
                performanceResults.bundle.totalSize = totalBundleSize;
                
                // ActualizeazÄƒ dashboard-ul
                document.getElementById('bundleSize').textContent = totalBundleSize + ' KB';
                document.getElementById('bundleSize').className = 'metric-value ' + (totalBundleSize < 500 ? 'metric-good' : totalBundleSize < 1000 ? 'metric-warning' : 'metric-bad');
                
            } catch (error) {
                result += `âŒ Eroare la testarea bundle-ului: ${error.message}\n`;
            }
            
            results.innerHTML = result;
        }

        function testAssetOptimization() {
            const results = document.getElementById('bundleResults');
            let result = results.innerHTML + '\n\nğŸ¯ Testare Optimizare Assets:\n';
            
            try {
                const iframe = document.getElementById('appFrame');
                const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                
                // TesteazÄƒ comprimarea
                const scripts = iframeDoc.querySelectorAll('script[src]');
                let compressedScripts = 0;
                
                scripts.forEach(script => {
                    if (script.src.includes('.min.') || script.src.includes('prod')) {
                        compressedScripts++;
                    }
                });
                
                result += `ğŸ“¦ Scripturi comprimate: ${compressedScripts}/${scripts.length}\n`;
                
                // TesteazÄƒ lazy loading
                const images = iframeDoc.querySelectorAll('img');
                let lazyImages = 0;
                
                images.forEach(img => {
                    if (img.loading === 'lazy' || img.hasAttribute('data-src')) {
                        lazyImages++;
                    }
                });
                
                result += `ğŸ–¼ï¸ Imagini lazy loading: ${lazyImages}/${images.length}\n`;
                
                // TesteazÄƒ cache-ul
                const cacheableElements = iframeDoc.querySelectorAll('[class*="cache"], [data-cache]');
                result += `ğŸ’¾ Elemente cache-abile: ${cacheableElements.length}\n`;
                
                performanceResults.bundle.compressedScripts = compressedScripts;
                performanceResults.bundle.lazyImages = lazyImages;
                performanceResults.bundle.cacheableElements = cacheableElements.length;
                
            } catch (error) {
                result += `âŒ Eroare la testarea optimizÄƒrii: ${error.message}\n`;
            }
            
            results.innerHTML = result;
        }

        function testCoreWebVitals() {
            const results = document.getElementById('vitalsResults');
            let result = 'ğŸ¯ Testare Core Web Vitals:\n';
            
            try {
                // TesteazÄƒ LCP (Largest Contentful Paint)
                if ('PerformanceObserver' in window) {
                    const lcpObserver = new PerformanceObserver((list) => {
                        const entries = list.getEntries();
                        const lastEntry = entries[entries.length - 1];
                        const lcp = lastEntry.startTime;
                        
                        result += `ğŸ¯ LCP: ${lcp.toFixed(2)}ms\n`;
                        
                        if (lcp < 2500) {
                            result += 'âœ… LCP excelent (< 2.5s)\n';
                        } else if (lcp < 4000) {
                            result += 'âš ï¸ LCP bun (2.5-4s)\n';
                        } else {
                            result += 'âŒ LCP slab (> 4s)\n';
                        }
                        
                        performanceResults.vitals.lcp = lcp;
                    });
                    
                    lcpObserver.observe({ entryTypes: ['largest-contentful-paint'] });
                }
                
                // TesteazÄƒ FID (First Input Delay)
                if ('PerformanceObserver' in window) {
                    const fidObserver = new PerformanceObserver((list) => {
                        const entries = list.getEntries();
                        entries.forEach(entry => {
                            const fid = entry.processingStart - entry.startTime;
                            
                            result += `ğŸ¯ FID: ${fid.toFixed(2)}ms\n`;
                            
                            if (fid < 100) {
                                result += 'âœ… FID excelent (< 100ms)\n';
                            } else if (fid < 300) {
                                result += 'âš ï¸ FID bun (100-300ms)\n';
                            } else {
                                result += 'âŒ FID slab (> 300ms)\n';
                            }
                            
                            performanceResults.vitals.fid = fid;
                        });
                    });
                    
                    fidObserver.observe({ entryTypes: ['first-input'] });
                }
                
                // TesteazÄƒ CLS (Cumulative Layout Shift)
                if ('PerformanceObserver' in window) {
                    let clsValue = 0;
                    const clsObserver = new PerformanceObserver((list) => {
                        for (const entry of list.getEntries()) {
                            if (!entry.hadRecentInput) {
                                clsValue += entry.value;
                            }
                        }
                        
                        result += `ğŸ¯ CLS: ${clsValue.toFixed(4)}\n`;
                        
                        if (clsValue < 0.1) {
                            result += 'âœ… CLS excelent (< 0.1)\n';
                        } else if (clsValue < 0.25) {
                            result += 'âš ï¸ CLS bun (0.1-0.25)\n';
                        } else {
                            result += 'âŒ CLS slab (> 0.25)\n';
                        }
                        
                        performanceResults.vitals.cls = clsValue;
                    });
                    
                    clsObserver.observe({ entryTypes: ['layout-shift'] });
                }
                
            } catch (error) {
                result += `âŒ Eroare la testarea Core Web Vitals: ${error.message}\n`;
            }
            
            results.innerHTML = result;
        }

        function testLighthouse() {
            const results = document.getElementById('vitalsResults');
            let result = results.innerHTML + '\n\nğŸ  Testare Lighthouse:\n';
            
            try {
                // SimuleazÄƒ un test Lighthouse simplu
                const loadTime = performance.timing.loadEventEnd - performance.timing.navigationStart;
                const memoryUsage = performance.memory ? performance.memory.usedJSHeapSize / 1024 / 1024 : 0;
                
                let score = 100;
                
                // Deduce puncte pe baza performanÈ›ei
                if (loadTime > 3000) score -= 20;
                if (loadTime > 5000) score -= 30;
                if (memoryUsage > 100) score -= 15;
                if (memoryUsage > 200) score -= 25;
                
                result += `ğŸ  Scor Lighthouse estimat: ${score}/100\n`;
                
                if (score >= 90) {
                    result += 'âœ… PerformanÈ›Äƒ excelentÄƒ\n';
                } else if (score >= 70) {
                    result += 'âš ï¸ PerformanÈ›Äƒ bunÄƒ\n';
                } else {
                    result += 'âŒ PerformanÈ›Äƒ slabÄƒ\n';
                }
                
                performanceResults.vitals.lighthouseScore = score;
                
            } catch (error) {
                result += `âŒ Eroare la testarea Lighthouse: ${error.message}\n`;
            }
            
            results.innerHTML = result;
        }

        function generatePerformanceReport() {
            const results = document.getElementById('performanceReport');
            let report = 'ğŸ“Š RAPORT PERFORMANÈšÄ‚ - ORDERFLOW PWA\n';
            report += '='.repeat(50) + '\n\n';
            
            report += `ğŸ“… Data: ${new Date().toLocaleString('ro-RO')}\n`;
            report += `ğŸ–¥ï¸ Browser: ${navigator.userAgent}\n`;
            report += `ğŸ“± RezoluÈ›ie: ${window.innerWidth}x${window.innerHeight}\n\n`;
            
            report += 'ğŸ“Š REZULTATE PERFORMANÈšÄ‚:\n';
            report += '-'.repeat(30) + '\n';
            
            // Load Times
            report += '\nâ±ï¸ TIMPURI ÃNCÄ‚RCARE:\n';
            report += `Total: ${performanceResults.loadTimes.total || 'N/A'}ms\n`;
            report += `DOM Content Loaded: ${performanceResults.loadTimes.domContentLoaded || 'N/A'}ms\n`;
            report += `First Paint: ${performanceResults.loadTimes.firstPaint || 'N/A'}ms\n`;
            report += `Resurse: ${performanceResults.loadTimes.resources || 'N/A'}\n`;
            
            // Memory
            report += '\nğŸ’¾ MEMORIE:\n';
            report += `FolositÄƒ: ${performanceResults.memory.used || 'N/A'} MB\n`;
            report += `Total: ${performanceResults.memory.total || 'N/A'} MB\n`;
            report += `LimitÄƒ: ${performanceResults.memory.limit || 'N/A'} MB\n`;
            report += `Procent: ${performanceResults.memory.usagePercent ? performanceResults.memory.usagePercent.toFixed(1) + '%' : 'N/A'}\n`;
            
            // Bundle
            report += '\nğŸ“¦ BUNDLE:\n';
            report += `Scripturi: ${performanceResults.bundle.scripts || 'N/A'}\n`;
            report += `CSS: ${performanceResults.bundle.css || 'N/A'}\n`;
            report += `Dimensiune totalÄƒ: ${performanceResults.bundle.totalSize || 'N/A'} KB\n`;
            report += `Scripturi comprimate: ${performanceResults.bundle.compressedScripts || 'N/A'}\n`;
            
            // Vitals
            report += '\nğŸ¯ CORE WEB VITALS:\n';
            report += `LCP: ${performanceResults.vitals.lcp ? performanceResults.vitals.lcp.toFixed(2) + 'ms' : 'N/A'}\n`;
            report += `FID: ${performanceResults.vitals.fid ? performanceResults.vitals.fid.toFixed(2) + 'ms' : 'N/A'}\n`;
            report += `CLS: ${performanceResults.vitals.cls ? performanceResults.vitals.cls.toFixed(4) : 'N/A'}\n`;
            report += `Lighthouse Score: ${performanceResults.vitals.lighthouseScore || 'N/A'}/100\n`;
            
            report += '\nğŸ¯ RECOMANDÄ‚RI:\n';
            report += '-'.repeat(20) + '\n';
            report += '1. OptimizeazÄƒ timpii de Ã®ncÄƒrcare (< 3s)\n';
            report += '2. ReduceÈ›i dimensiunea bundle-ului\n';
            report += '3. ImplementaÈ›i lazy loading pentru imagini\n';
            report += '4. OptimizaÈ›i utilizarea memoriei\n';
            report += '5. TestaÈ›i pe dispozitive cu performanÈ›Äƒ redusÄƒ\n';
            
            results.innerHTML = report;
        }

        // PorneÈ™te monitorizarea performanÈ›ei la Ã®ncÄƒrcarea paginii
        window.addEventListener('load', function() {
            startPerformanceMonitoring();
            testLoadTimes();
            testMemoryUsage();
            testBundleSizes();
        });

        // OpreÈ™te monitorizarea cÃ¢nd se Ã®nchide pagina
        window.addEventListener('beforeunload', function() {
            stopPerformanceMonitoring();
        });
    </script>
</body>
</html>
